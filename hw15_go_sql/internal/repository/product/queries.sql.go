// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: queries.sql

package product

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const CreateOrder = `-- name: CreateOrder :one
insert into  orders (user_id, order_date, total_amount)
VALUES ($1, $2, $3)
returning id
`

type CreateOrderParams struct {
	UserID      uuid.UUID          `db:"user_id" json:"user_id"`
	OrderDate   pgtype.Timestamptz `db:"order_date" json:"order_date"`
	TotalAmount pgtype.Numeric     `db:"total_amount" json:"total_amount"`
}

func (q *Queries) CreateOrder(ctx context.Context, arg CreateOrderParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, CreateOrder, arg.UserID, arg.OrderDate, arg.TotalAmount)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const CreateOrderWithCurrentDate = `-- name: CreateOrderWithCurrentDate :one
insert into  orders (user_id, total_amount)
VALUES ($1, $2)
returning id
`

type CreateOrderWithCurrentDateParams struct {
	UserID      uuid.UUID      `db:"user_id" json:"user_id"`
	TotalAmount pgtype.Numeric `db:"total_amount" json:"total_amount"`
}

func (q *Queries) CreateOrderWithCurrentDate(ctx context.Context, arg CreateOrderWithCurrentDateParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, CreateOrderWithCurrentDate, arg.UserID, arg.TotalAmount)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const CreateProduct = `-- name: CreateProduct :one
insert into products (name, price)
VALUES ($1, $2)
returning id
`

type CreateProductParams struct {
	Name  string         `db:"name" json:"name"`
	Price pgtype.Numeric `db:"price" json:"price"`
}

func (q *Queries) CreateProduct(ctx context.Context, arg CreateProductParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, CreateProduct, arg.Name, arg.Price)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const CreateUser = `-- name: CreateUser :one
insert into  users (name, email, password)
VALUES ($1, $2, $3)
returning id
`

type CreateUserParams struct {
	Name     string `db:"name" json:"name"`
	Email    string `db:"email" json:"email"`
	Password string `db:"password" json:"password"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, CreateUser, arg.Name, arg.Email, arg.Password)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const DeleteOrder = `-- name: DeleteOrder :one
delete from orders
WHERE id = $1
returning id
`

func (q *Queries) DeleteOrder(ctx context.Context, id uuid.UUID) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, DeleteOrder, id)
	err := row.Scan(&id)
	return id, err
}

const DeleteProduct = `-- name: DeleteProduct :one
delete from products
WHERE id = $1
returning id
`

func (q *Queries) DeleteProduct(ctx context.Context, id uuid.UUID) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, DeleteProduct, id)
	err := row.Scan(&id)
	return id, err
}

const DeleteUser = `-- name: DeleteUser :one
delete from users
WHERE id = $1
returning id
`

func (q *Queries) DeleteUser(ctx context.Context, id uuid.UUID) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, DeleteUser, id)
	err := row.Scan(&id)
	return id, err
}

const GetAllOrders = `-- name: GetAllOrders :many
select id, user_id, order_date, total_amount from orders
`

func (q *Queries) GetAllOrders(ctx context.Context) ([]*Order, error) {
	rows, err := q.db.Query(ctx, GetAllOrders)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Order{}
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.OrderDate,
			&i.TotalAmount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetAllProducts = `-- name: GetAllProducts :many
select id, name, price from products
`

func (q *Queries) GetAllProducts(ctx context.Context) ([]*Product, error) {
	rows, err := q.db.Query(ctx, GetAllProducts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Product{}
	for rows.Next() {
		var i Product
		if err := rows.Scan(&i.ID, &i.Name, &i.Price); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetAllUsers = `-- name: GetAllUsers :many
select id, name, email, password from users
`

func (q *Queries) GetAllUsers(ctx context.Context) ([]*User, error) {
	rows, err := q.db.Query(ctx, GetAllUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*User{}
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Email,
			&i.Password,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetOrdersByUser = `-- name: GetOrdersByUser :many
select id, user_id, order_date, total_amount from orders where user_id = $1
`

func (q *Queries) GetOrdersByUser(ctx context.Context, userID uuid.UUID) ([]*Order, error) {
	rows, err := q.db.Query(ctx, GetOrdersByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Order{}
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.OrderDate,
			&i.TotalAmount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetProductById = `-- name: GetProductById :one
select id, name, price from products where id = $1
`

func (q *Queries) GetProductById(ctx context.Context, id uuid.UUID) (*Product, error) {
	row := q.db.QueryRow(ctx, GetProductById, id)
	var i Product
	err := row.Scan(&i.ID, &i.Name, &i.Price)
	return &i, err
}

const GetProductByName = `-- name: GetProductByName :one
select id, name, price from products where name = $1
`

func (q *Queries) GetProductByName(ctx context.Context, name string) (*Product, error) {
	row := q.db.QueryRow(ctx, GetProductByName, name)
	var i Product
	err := row.Scan(&i.ID, &i.Name, &i.Price)
	return &i, err
}

const GetUserAvaragePrice = `-- name: GetUserAvaragePrice :one
select avg(total_amount) from orders where user_id = $1
`

func (q *Queries) GetUserAvaragePrice(ctx context.Context, userID uuid.UUID) (float64, error) {
	row := q.db.QueryRow(ctx, GetUserAvaragePrice, userID)
	var avg float64
	err := row.Scan(&avg)
	return avg, err
}

const GetUserById = `-- name: GetUserById :one
select id, name, email, password from users where id = $1
`

func (q *Queries) GetUserById(ctx context.Context, id uuid.UUID) (*User, error) {
	row := q.db.QueryRow(ctx, GetUserById, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.Password,
	)
	return &i, err
}

const GetUserByName = `-- name: GetUserByName :one
select id, name, email, password from users where name = $1
`

func (q *Queries) GetUserByName(ctx context.Context, name string) (*User, error) {
	row := q.db.QueryRow(ctx, GetUserByName, name)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.Password,
	)
	return &i, err
}

const GetUserTotalPrice = `-- name: GetUserTotalPrice :one
select sum(total_amount) from orders where user_id = $1
`

func (q *Queries) GetUserTotalPrice(ctx context.Context, userID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, GetUserTotalPrice, userID)
	var sum int64
	err := row.Scan(&sum)
	return sum, err
}

const SordUserById = `-- name: SordUserById :many
select id, name, email, password from users order by id limit $1
`

func (q *Queries) SordUserById(ctx context.Context, limit int32) ([]*User, error) {
	rows, err := q.db.Query(ctx, SordUserById, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*User{}
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Email,
			&i.Password,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const SortProductByPriceASC = `-- name: SortProductByPriceASC :many
select id, name, price from products order by price asc limit $1
`

func (q *Queries) SortProductByPriceASC(ctx context.Context, limit int32) ([]*Product, error) {
	rows, err := q.db.Query(ctx, SortProductByPriceASC, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Product{}
	for rows.Next() {
		var i Product
		if err := rows.Scan(&i.ID, &i.Name, &i.Price); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const SortProductByPriceDESC = `-- name: SortProductByPriceDESC :many
select id, name, price from products order by price desc limit $1
`

func (q *Queries) SortProductByPriceDESC(ctx context.Context, limit int32) ([]*Product, error) {
	rows, err := q.db.Query(ctx, SortProductByPriceDESC, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Product{}
	for rows.Next() {
		var i Product
		if err := rows.Scan(&i.ID, &i.Name, &i.Price); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpdateProduct = `-- name: UpdateProduct :one
update products
SET name = $2,
    price = $3
WHERE id = $1
returning id
`

type UpdateProductParams struct {
	ID    uuid.UUID      `db:"id" json:"id"`
	Name  string         `db:"name" json:"name"`
	Price pgtype.Numeric `db:"price" json:"price"`
}

func (q *Queries) UpdateProduct(ctx context.Context, arg UpdateProductParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, UpdateProduct, arg.ID, arg.Name, arg.Price)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const UpdateUser = `-- name: UpdateUser :one
update users
SET name = $2,
    email = $3
WHERE id = $1
returning id
`

type UpdateUserParams struct {
	ID    uuid.UUID `db:"id" json:"id"`
	Name  string    `db:"name" json:"name"`
	Email string    `db:"email" json:"email"`
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, UpdateUser, arg.ID, arg.Name, arg.Email)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}
